using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text;
using VrSharp;
using VrSharp.Gvr;
using VrSharp.Pvr;
using SAModel;
using static ArchiveLib.GenericArchive;

// PVM/GVM archives used in Dreamcast/Gamecube games and their ports.
namespace ArchiveLib
{
    public enum PuyoArchiveType
    {
        Unknown,
        PVMFile,
        GVMFile,
    }

    public class PuyoFile : GenericArchive
    {
        // Archive chunks
        const uint Magic_PVM = 0x484D5650; // PVMH archive
        const uint Magic_GVM = 0x484D5647; // GVMH archive

        // PVM metadata chunks
        const uint Magic_MDLN = 0x4E4C444D; // Model Name
        const uint Magic_COMM = 0x4D4D4F43; // Model Comment
        const uint Magic_CONV = 0x564E4F43; // PVM Converter
        const uint Magic_IMGC = 0x43474D49; // Image Container
        const uint Magic_PVMI = 0x494D5650; // PVM File Info

        // Texture chunks
        const uint Magic_GBIX = 0x58494247; // PVR texture header (GBIX)
        const uint Magic_PVRT = 0x54525650; // PVR texture header (texture data)
        const uint Magic_GVRT = 0x54525647; // GVR texture header (texture data)
        const uint Magic_PVRI = 0x49525650; // PVR texture header (metadata)

        public bool PaletteRequired;
        public PuyoArchiveType Type;

		[FlagsAttribute]
        public enum PuyoArchiveFlags : ushort
        {
            GlobalIndex = 0x1,
            TextureDimensions = 0x2,
            PixelDataFormat = 0x4,
            Filenames = 0x8,
            ModelName = 0x10,
            Unknown = 0x100, // "Generated by PVMConv" maybe?
        }

        public override void CreateIndexFile(string path)
        {
            using (TextWriter texList = File.CreateText(Path.Combine(path, "index.txt")))
            {
                foreach (GenericArchiveEntry pvmentry in Entries)
                {
                    texList.WriteLine(pvmentry.Name);
                }
                texList.Flush();
                texList.Close();
            }
        }

        public static PuyoArchiveType Identify(byte[] data)
        {
            uint magic = BitConverter.ToUInt32(data, 0);
            switch (magic)
            {
                case Magic_PVM:
                    return PuyoArchiveType.PVMFile;
                case Magic_GVM:
                    return PuyoArchiveType.GVMFile;
                default:
                    return PuyoArchiveType.Unknown;
            }
        }

		/// <summary>
		/// This function sets all textures in the archive to use the specified PVP/GVP palette file.
		/// If the specified palette file exists, the PaletteRequired flag is removed.
		/// </summary>
		public void SetPalette(string palettePath) 
		{
			if (File.Exists(palettePath))
			{
				VpPalette Palette = null;
				bool gvm = Type == PuyoArchiveType.GVMFile;
				Palette = gvm ? (VpPalette)new GvpPalette(palettePath) : (VpPalette)new PvpPalette(palettePath);
				foreach (GenericArchiveEntry entry in Entries)
				{
					if (entry is PVMEntry pvme)
					{
						PvrTexture pvrt = new PvrTexture(pvme.Data);
						if (pvrt.NeedsExternalPalette)
							pvme.Palette = (PvpPalette)Palette;
					}
					else if (entry is GVMEntry gvme)
					{
						GvrTexture gvrt = new GvrTexture(gvme.Data);
						if (gvrt.NeedsExternalPalette)
							gvme.Palette = (GvpPalette)Palette;
					}
				}
				PaletteRequired = false;
			}
		}

		/// <summary>
		/// This function displays a dialog to select a PVP/GVP palette file and sets all textures in the archive to use the specified palette. 
		/// </summary>
		public void AddPaletteFromDialog(string startPath)
		{
			bool gvm = Type == PuyoArchiveType.GVMFile;
			using (System.Windows.Forms.OpenFileDialog a = new System.Windows.Forms.OpenFileDialog
			{
				DefaultExt = gvm ? "gvp" : "pvp",
				Filter = gvm ? "GVP Files|*.gvp" : "PVP Files|*.pvp",
				InitialDirectory = startPath,
				Title = "External palette file"
			})
				if (a.ShowDialog() == System.Windows.Forms.DialogResult.OK)
					SetPalette(a.FileName);
		}

        public PuyoFile(bool gvm = false) 
        {
            Type = gvm ? PuyoArchiveType.GVMFile : PuyoArchiveType.PVMFile;
        }

        /// <summary>
        /// This function checks the specified offset in a byte array to verify if it begins with a PVR/GVR texture header. 
		/// Sometimes there is padding or metadata that needs to be skipped in order to read the texture.
		/// The function loops through the array until it finds a PVRT/GVRT header and returns its offset.
        /// </summary>
        public int GetPVRTOffset(byte[] pvmdata, int offset)
        {
            uint header = BitConverter.ToUInt32(pvmdata, offset);
            int currentoffset = offset;
            switch (header)
            {
                // If a valid texture header is found, that's it
                case Magic_PVRT:
                case Magic_GVRT:
                    return currentoffset;

                // If a metadata chunk is recognized, skip it
                case Magic_MDLN:
                case Magic_CONV:
                case Magic_IMGC:
                case Magic_COMM:
                case Magic_PVMI:
                case Magic_PVRI: // This one probably shouldn't be here but there are no known examples yet of how this was used
                    int size = BitConverter.ToInt32(pvmdata, offset + 4);
                    currentoffset += size + 8;
                    // Go through the metadata until it gets to a PVRT/GVRT header
                    return GetPVRTOffset(pvmdata, currentoffset);

                // If the header is unrecognized, add 1 byte to the offset and continue looking
                default:
                    currentoffset += 1;
                    // Go through the padding until it gets to a PVRT/GVRT header
                    return GetPVRTOffset(pvmdata, currentoffset);
            }
        }

        public PuyoFile(byte[] pvmdata)
        {
            bool bigendianbk = ByteConverter.BigEndian;
            Entries = new List<GenericArchiveEntry>();
            Type = Identify(pvmdata);
            switch (Type)
            {
                case PuyoArchiveType.PVMFile:
                    ByteConverter.BigEndian = false;
                    break;
                case PuyoArchiveType.GVMFile:
                    ByteConverter.BigEndian = true;
                    break;
                default:
                    throw new Exception("Error: Unknown archive format");
            }

            // Get PVM/GVM flags and calculate item size in the entry table
            ushort numtextures = ByteConverter.ToUInt16(pvmdata, 0x0A);
            int pvmentrysize = 2;
            int gbixoffset = 0;
            int nameoffset = 0;

            PuyoArchiveFlags flags = (PuyoArchiveFlags)ByteConverter.ToUInt16(pvmdata, 0x08);
            if (flags.HasFlag(PuyoArchiveFlags.Filenames))
                nameoffset = pvmentrysize;
            pvmentrysize += 28;
            if (flags.HasFlag(PuyoArchiveFlags.PixelDataFormat))
                pvmentrysize += 2;
            if (flags.HasFlag(PuyoArchiveFlags.TextureDimensions))
                pvmentrysize += 2;
            if (flags.HasFlag(PuyoArchiveFlags.GlobalIndex))
                gbixoffset = pvmentrysize;
            pvmentrysize += 4;

            int offsetfirst = BitConverter.ToInt32(pvmdata, 0x4) + 8; // Always Little Endian
            int textureaddr = GetPVRTOffset(pvmdata, offsetfirst); // Where texture data begins

            for (int t = 0; t < numtextures; t++)
            {
                int size_gbix = flags.HasFlag(PuyoArchiveFlags.GlobalIndex) ? 16 : 0;
                int size = BitConverter.ToInt32(pvmdata, textureaddr + 4); // Always Little Endian
                byte[] pvrchunk = new byte[size + 8 + size_gbix];

                // Handle cases when data size in the PVR/GVR header goes beyond the range of the archive (Billy Hatcher)
                if ((textureaddr + size + 8) > pvmdata.Length)
                    do
                        size--;
                    while ((textureaddr + size + 8) > pvmdata.Length);

                Array.Copy(pvmdata, textureaddr, pvrchunk, 0 + size_gbix, size + 8);
                // Add GBIX header if the PVM/GVM has GBIX enabled
                if (flags.HasFlag(PuyoArchiveFlags.GlobalIndex))
                {
                    Array.Copy(BitConverter.GetBytes(Magic_GBIX), 0, pvrchunk, 0, 4); // Little Endian
                    pvrchunk[4] = 0x08; // Always 8 according to PuyoTools
                    uint gbix = BitConverter.ToUInt32(pvmdata, 0xC + pvmentrysize * t + gbixoffset);
                    byte[] gbixb = BitConverter.GetBytes(gbix);
                    Array.Copy(gbixb, 0, pvrchunk, 8, 4);
                }

                // Set filename if the PVM/GVM has filenames
                string entryfn = t.ToString("D3");
                if (flags.HasFlag(PuyoArchiveFlags.Filenames))
                {
                    byte[] namestring = new byte[28];
                    for (int n = 0; n < 28; n++)
                    {
                        // Entry names in some PVMs (e.g. DEMO.PVM in Dream Passport 3) have garbage data after the first 0, so it needs to be truncated
                        byte ndt = pvmdata[0xC + pvmentrysize * t + nameoffset + n];
                        if (ndt == 0)
                            break;
                        namestring[n] = ndt;
                    }
                    entryfn = Encoding.ASCII.GetString(namestring).TrimEnd((char)0);
                }

                if (t < numtextures - 1)  // Get the address of the next PVRT chunk, unless it's the last one
                    textureaddr = GetPVRTOffset(pvmdata, textureaddr + size + 8);

                // Add PVR/GVR texture to the entry list
                if (Type == PuyoArchiveType.PVMFile)
                {
                    PvrTexture pvrt = new PvrTexture(pvrchunk);
                    if (pvrt.NeedsExternalPalette)
                        PaletteRequired = true;
                    Entries.Add(new PVMEntry(pvrchunk, entryfn + ".pvr"));
                }
                else
                {
                    GvrTexture gvrt = new GvrTexture(pvrchunk);
                    if (gvrt.NeedsExternalPalette)
                        PaletteRequired = true;
                    Entries.Add(new GVMEntry(pvrchunk, entryfn + ".gvr"));
                }
            }
            ByteConverter.BigEndian = bigendianbk;
        }

        public override byte[] GetBytes()
        {
            bool bigendianbk = ByteConverter.BigEndian;
            ByteConverter.BigEndian = Type == PuyoArchiveType.GVMFile;
            List<byte> result = new List<byte>();
            result.AddRange(Type == PuyoArchiveType.PVMFile ? BitConverter.GetBytes(Magic_PVM) : BitConverter.GetBytes(Magic_GVM));

            // Create entry list
            List<byte> entrytable = new List<byte>();
            uint firstoffset = 12;
            for (int i = 0; i < Entries.Count; i++)
            {
                entrytable.AddRange(ByteConverter.GetBytes((ushort)i));
                byte[] namestring = System.Text.Encoding.ASCII.GetBytes(Path.GetFileNameWithoutExtension(Entries[i].Name));
                byte[] namefull = new byte[28];
                Array.Copy(namestring, namefull, namestring.Length);
                entrytable.AddRange(namefull);
                ushort dimensions = 0;
                uint gbix = 0;
                if (Entries[i] is PVMEntry pvme)
                {
                    PvrTexture pvrt = new PvrTexture(pvme.Data);
                    entrytable.Add((byte)pvrt.PixelFormat);
                    entrytable.Add((byte)pvrt.DataFormat);
                    dimensions |= (ushort)(((byte)Math.Log(pvrt.TextureWidth, 2) - 2) & 0xF);
                    dimensions |= (ushort)((((byte)Math.Log(pvrt.TextureHeight, 2) - 2) & 0xF) << 4);
                    gbix = pvrt.GlobalIndex;
                }
                else if (Entries[i] is GVMEntry gvme)
                {
                    GvrTexture gvrt = new GvrTexture(gvme.Data);
                    entrytable.Add((byte)gvrt.PixelFormat);
                    entrytable.Add((byte)gvrt.DataFormat);
                    dimensions |= (ushort)(((byte)Math.Log(gvrt.TextureWidth, 2) - 2) & 0xF);
                    dimensions |= (ushort)((((byte)Math.Log(gvrt.TextureHeight, 2) - 2) & 0xF) << 4);
                    gbix = gvrt.GlobalIndex;
                }
                entrytable.AddRange(ByteConverter.GetBytes(dimensions));
                entrytable.AddRange(ByteConverter.GetBytes(gbix));
            }

            // Add padding if the data isn't aligned by 16
            if ((12 + entrytable.Count) % 16 != 0)
            {
                do
                {
                    entrytable.Add(0);
                }
                while ((12 + entrytable.Count) % 16 != 0);
            }

            // Write other header stuff
            result.AddRange(BitConverter.GetBytes((uint)(firstoffset+entrytable.Count-8))); // Offset of the first texture, Little Endian
            result.AddRange(ByteConverter.GetBytes((ushort)0xF)); // PVM/GVM flags
            result.AddRange(ByteConverter.GetBytes((ushort)Entries.Count));
            result.AddRange(entrytable);
            
            // Write texture data
            for (int i = 0; i < Entries.Count; i++)
            {
                // Align by 16
                int length = Entries[i].Data.Length - 16;
                if (length % 16 != 0)
                    do
                        length++;
                    while (length % 16 != 0);
                byte[] nogbix = new byte[length];
                Array.Copy(Entries[i].Data, 16, nogbix, 0, Entries[i].Data.Length - 16);
                result.AddRange(nogbix);
            }
            ByteConverter.BigEndian = bigendianbk;
            return result.ToArray();
        }
    }

    public class PVMEntry : GenericArchiveEntry
    {
        public uint GBIX;
        public PvpPalette Palette;

        public PVMEntry(byte[] pvrdata, string name)
        {
            Name = name;
            Data = pvrdata;
            PvrTexture pvrt = new PvrTexture(pvrdata);
            GBIX = pvrt.GlobalIndex;
        }

        public PVMEntry(string filename)
        {
            Name = Path.GetFileName(filename);
            Data = File.ReadAllBytes(filename);
            PvrTexture pvrt = new PvrTexture(Data);
            GBIX = pvrt.GlobalIndex;
        }

        public uint GetGBIX()
        {
            return GBIX;
        }

        public override Bitmap GetBitmap()
        {
            PvrTexture pvrt = new PvrTexture(Data);
            if (pvrt.NeedsExternalPalette)
                pvrt.SetPalette(Palette);
            return pvrt.ToBitmap();
        }
    }

    public class GVMEntry : GenericArchiveEntry
    {
        public uint GBIX;
        public GvpPalette Palette;

        public GVMEntry(byte[] gvrdata, string name)
        {
            Name = name;
            Data = gvrdata;
            GvrTexture gvrt = new GvrTexture(gvrdata);
            GBIX = gvrt.GlobalIndex;
        }

        public GVMEntry(string filename)
        {
            Name = Path.GetFileName(filename);
            Data = File.ReadAllBytes(filename);
            GvrTexture gvrt = new GvrTexture(Data);
            GBIX = gvrt.GlobalIndex;
        }

        public uint GetGBIX()
        {
            return GBIX;
        }

        public override Bitmap GetBitmap()
        {
            GvrTexture gvrt = new GvrTexture(Data);
            if (gvrt.NeedsExternalPalette)
                gvrt.SetPalette(Palette);
            return gvrt.ToBitmap();
        }
    }
}
